%!TEX root = main.tex
\chapter{Constraint Programming}

\section{Introduction}

Constraint Satisfaction, in it's most basic form, consists in finding a value for each one of a set of problems where constraints specify the restrictions related to those problems.

Constraint Satisfaction Problems have been tackled by the most various methods, from automata theory to ant algorithms and are a topic of interest in many fields of computer science~\cite{Rossi2006}.

\section{History of Constraint Programming}

Before understanding what constraint programming is we need to understand that Constraint Satisfaction is the process of finding a solution to a set of constraints that impose conditions that the variables must satisfy~\cite{Krzysztof2003}. A solution is found when a set of variables satisfies all constrains. These constraints and variables will be explained in deeper detail later in section~\ref{working}.

Constraint Satisfaction originally appeared in the field of artificial intelligence in the early 1970s. During the 1980s and 1990s constraints started being embedded into programming languages, as they were being developed, and the term constraint programing started taking form. Examples of these programming languages are \textit{Prolog} and \textit{C++}~\cite{Krzysztof2003}.

In artificial intelligence interest in constraint satisfaction developed into two streams, the language stream and the algorithm stream. The first stream refers to the side of Constraint Satisfaction that deals with algebraic equations, constraint statements and declarative languages, while the second stream refers to actual algorithms used to solve said constrains~\cite{Rossi2006}.

\section{Working with Constraint Programming}
\label{working}

There are several definitions we have to delve into to better understand how constraint programming works. We need to fully understand what a domain and a variable is and we also need to know what a constraint is.

\subsection{Variable}
\label{variable}

A variable has several known definitions, the one we want is in the field of mathematics. According to mathematics a variable is a symbol, usually an alphabetic character, and it represents a number, known as the value of the variable, which can be arbitrary, not fully specified or unknown~\cite{Menger1954}.

\subsection{Domain}

A domain, like the variable, also has various known definitions, however the one that interests us here is in the field of mathematical analysis. 

According to Hans Hahn, an open set is connected if it cannot be expressed as the sum of two open sets. An open connected set is called a domain~\cite{Hahn1921} 

In our case, a domain is an open connected set of variables.

\section{Approaches to Constraint Programming}

In constraint programming, we usually have a set of variables, which takes values from an initial domain, to which constraints are applied in order to reduce its domain, and thus reach a solution. Once a constraint is placed on the system it cannot violate another constraint previously applied. This way, we can express the requirements of the possible values of the variables~\cite{Pearson1997}.

Constraint satisfaction problems are typically solved with the help of solvers. These solvers are essentially search algorithms, usually based on backtracking techniques\cite{Knuth1997}, constraint propagation \cite{Lecoutre2010} or local search \cite{Dechter2003}. 

\subsection{Backtracking}

Backtracking is a search method that incrementally finds possible candidates to solve the problem. At the same time it removes the candidates that can not be used as a valid solution to the problem~\cite{Knuth1997}. One of the most used examples for this type of search method is the n-queens puzzle, where a set of $n$ queens should be organized, in a $n \times n$ chess board, in such a way that none of the queens can attack each other. Any partial solution that contains two queens that can attack each other is abandoned immediately.

\subsection{Constraint Propagation}

Constraint propagation starts by reducing the variable's domain, strengthening or creating new constraints, reducing the search space, leading to a problem that is easier to solve. Since this algorithm only reduces the search space of the problem variables. After completion, there is still the need to use another algorithm to solve the problem, which is now converted into a simpler problem by the propagators \cite{Lecoutre2010}. 

\subsection{Local Search}

Local search is an incomplete search method to find solutions for a problem. It consists in, iteratively, and with the help of previously defined heuristics, assigning values to the problem variables until all the constraints are satisfied. At each step of the iteration, the values of the variables are updated to values \emph{near} the previous value. The algorithm also knows the cost associated with the assignment of specific values to variables, allowing to check if a candidate solution has with a pre-defined cost~\cite{Dechter2003}.

\section{Known Tools and Other Approaches}

\subsection{Choco}

Choco is an open source and free access library dedicated to constraint programming. It is written in Java and supports several types of variables, including Integers, Booleans, Sets and Reals. It also supports several types of constraints such as AllDifferent and Count, configurable search algorithms and conflict explaining. The first version of Choco was developed in the early 2000s. A few years later, Choco 2 was developed and declared a success in the academic and industrial world. Since then, Choco has been completely re-written and in 2012 the third version of Choco was launched. The current version comes with a simpler API and is denominated Choco 4~\cite{chocoSolver}.

\subsection{Gecode}

Gecode is a free access, open source, portable, accessible and efficient programming environment used to develop systems and applications based on restrictions. Gecode, much like Choco, supports various types of variables and restrictions, among them are Integers, Float and Sets. These variables are used to model problems that are then solved with the help of constraint propagators and search algorithms \cite{MPG:M:5.1.0}~\cite{gecode}.

\subsection{Google OR-Tools}

Although Choco and Gecode are two of the most widely used libraries, there are also other new tools, such as the Google OR-Tools~\cite{ORTools}. Google Optimization Tools or OR-Tools is an interface that puts together several linear programming solver and that counts on the use of several types of algorithms such as search algorithms and graph algorithms. What this library has that is so noteworthy is the fact that it doesn't let itself be bound by one language. Although implemented in C++, it can be used in other languages like Python, C\# or Java.